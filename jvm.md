# JVM性能调优

## JVM 虚拟机概览

JVM不单单只支持Java语言，也支持其他语言（Scala、Kotlin、Groovy等等）

区块链2.0--以太坊(比特币是区块链1.0) 中提供了EVM的虚拟机，它的实现和JVM类似，基于栈、生成脚本编译成字节码来执行。知识通用。（理论大于实际）

- 虚拟机历史

  解释执行和编译执行（针对字节码的执行）

  解释执行就是边翻译为机器码边执行、即时编译（编译执行）就是先将一个方法中的所有字节码全部编译成机器码之后再执行。

  Hotspot采用的是先解释执行，到了一定时机后热点代码（多次执行、循环等）再翻译成机器码

  热点代码探测技术（通过执行计数器找到最有编译价值的代码，如果代码用得非常频繁，就会把这些代码编译成本地代码）。

  JRockit采取的方法是在执行class时直接编译为机器码（Java程序启动速度会比较慢）

  J9和Hotspot比较接近，主要是用在IBM产品（IBM WebSphere和IBM的AIX平台上），华为有的项目用的J9。

  谷歌：Google Android Dalivk VM：使用的寄存器架构，执行dex（Dalvik Executable）通过class转化而来。

- 未来的java 技术

  1. **模块化**:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向

  2. **混合语言**：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)

  3. **多核并行**：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)

  4. **丰富语法：**JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource

     **64**位：虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。

  5. **更强的垃圾回收器（现在主流CMS、G1）**：JDK11 –ZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间 JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB

- Java SE 体系架构

  JavaSE，Java平台标准版，为Java EE和Java ME提供了基础。

  JDK：Java开发工具包，JDK是JRE的超集，包含JRE中的所有内容，以及开发程序所需的编译器和调试程序等工具。

  JRE：Java SE运行时环境 ，提供库、Java虚拟机和其他组件来运行用Java编程语言编写的程序。主要类库，包括：程序部署发布、用户界面工具类、继承库、其他基础库，语言和工具基础库

  JVM：java虚拟机，负责JavaSE平台的硬件和操作系统无关性、编译执行代码（字节码）和平台安全性

### 运行时数据区域

参考资料：https://www.cnblogs.com/wuzhenzhao/p/12346515.html

这是个抽象概念，内部实现依赖寄存器，主内存（具体要分析JVM源码 C++实现）；计算机的运行 = 指令 + 数据， 指令用于执行方法的， 数据用于存放数据和对象的。

- 虚拟机栈： 执行java方法
- 本地方法栈：执行本地方法
- 程序计数器：程序执行的计数器

java中的数据：变量，常量，对象，数组相关

#### 程序计数器（线程私有）

较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响;

程序计数器作用确保多线程情况下的程序正常执行

如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数

如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）

此内存区域是唯一一个不会出现OutOfMemoryError情况的区域。

#### 虚拟机栈（线程私有）

每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。

栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k

在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

- 局部变量表：顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型）

- 操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进先出的栈结果，操作数栈，就是用来操作的，操作的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作

- 动态连接：java语言特性多态（需要类加载，运行时才能确定具体的方法）

- 返回地址； 正常返回（调用程序计数器中的地址作为返回）

  三部曲：

  1. 恢复上层方法的局部变量表和操作数栈
  2. 把返回值（如果有的话）压入调用者栈帧的操作数栈中
  3. 调整PC计数器的值以指向方法调用指令后面的一条指令
  4. 异常情况（通过异常处理器表（非栈帧中）来确定）

#### 本地方法栈（线程私有）

各虚拟机自由实现，本地方法栈native方法调用 JNI到了底层的C/C++(c/c++可以触发汇编语言，然后驱动硬件)

### 线程共享区域

类信息：

类的完整有效名、返回值类型、修饰符（public，private...）、变量名、方法名、方法代码、这个类型直接父类的完整有效名(除非这个类型是interface或是 java.lang.Object，两种情况下都没有父类)、类的直接接口的一个有序列表。

#### 方法区/永久代(元空间)

用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：

jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；

jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize

jdk1.8以后大小就只受本机总内存的限制

如：-XX:MaxMetaspaceSize=3M

#### 堆

几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：

-Xms：堆的最小值；

-Xmx：堆的最大值；

-Xmn：新生代的大小；

-XX:NewSize；新生代最小值；

-XX:MaxNewSize：新生代最大值；

例如- Xmx256m

#### 运行时常量池

Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域

### 辨析 堆&栈

1. 功能

   - 以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；
   -  而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；

2. 线程是独享还是共享

   - 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
   - 堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。

3. 空间大小

   栈的内存要远远小于堆内存

### 直接内存

使用Native函数库直接分配堆外内存(NIO)

并不是JVM运行时数据区域的一部分，但是会被频繁使用(可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样,也会出现OOM异常)

避免了在Java 堆和Native 堆中来回复制数据，能够提高效率

测试用例JavaStack：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围

## 虚拟机中的对象

### 对象创建过程

虚拟机遇到一条new指令时：根据new的参数是否能在常量池中定位到一个类的符号引用,如果没有，说明还未定义该类，抛出ClassNotFoundException；

1. 检查加载

   限制性相应的类的加载过程。如果没有，则进行类加载

2. 分配内存

   根据方法区的信息确定为该类分配的内存空间大小

   1. 指针碰撞（java堆内存空间规整的情况下使用）

      接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

      如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”。

   2. 空闲列表（java堆空间不规整的情况下使用）

      如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“**空闲列表**”。

      选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

3. 并发安全

   除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

   解决方案：

   1. CAS机制

   2. 分配缓冲

      每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。

      TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间（Eden区，默认Eden的1%），减少同步开销。

      TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。

4. 内存空间初始化

   （注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

5. 设置

   接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

6. 对象初始化

   在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**<u>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</u>**。

对象头包括两部分信息：

1. 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
2. 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。对象正好是9字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位

建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

1. 句柄

   如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

2. 直接指针

   如果使用直接指针访问， reference中存储的直接就是对象地址。

   这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

   使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

   对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。

### 堆内存分配策略

新生代：Eden区（80%），survivor（from）区（10%），survivor（to）区（10%）

老年代

-XX:+PrintGCDetails 打印垃圾回收日志，程序退出时输出当前内存的分配情况

1.  对象优先在Eden区分配

2. 大对象直接进入老年代

   -XX:PretenureSizeThreshold=4m

   retenureSizeThreshold参数只对Serial和ParNew两款收集器有效。

   最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。

3. 长期存活的对象进入老年代

   如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中

4. 对象年龄动态判定

   如果在 Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

5. 空间分配担保

   在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

## 垃圾回收

栈：栈中的生命周期是跟随线程的，所以一般不需要关注

堆：堆中的对象时垃圾回收的重点

方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是关注重点

### 判断对象是否存活

#### 引用计数法

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。（Python在用，但主流虚拟机没有使用）

优点：快，方便，实现简单。

缺陷：对象相互引用时（A.instance=B同时B.instance=A），很难判断对象是否该回收。

#### 可达性分析（java中使用）

来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

作为GC Roots的对象包括下面几种：

1. 当前虚拟机栈中局部变量表中的引用的对象
2. 当前本地方法栈中局部变量表中的引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中的常量引用的对象

### 引用

Reference中存储的数据代表的是另一块内存的起始地址

#### 强引用

一般的`Object obj = new Object()` ，就属于强引用。

（如果有GCroots的强引用）垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止

#### 软引用 SoftReference

垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收它

软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。

一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收

#### 弱引用 WeakReference

垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。

一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收

#### 虚引用 PhantomReference

幽灵引用，最弱，被垃圾回收的时候收到一个通知

如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动

## GC (Garbage Collection)

1. Minor GC

   **特点:** 发生在新生代上，发生的较频繁，执行速度较快

   **触发条件:** Eden区空间不足\空间分配担保

2. Full GC

   **特点:** 主要发生在老年代上（新生代也会回收），较少发生，执行速度较慢

   **触发条件:** 

   1. 调用 System.gc()
   2. 老年代区域空间不足
   3. 空间分配担保失败
   4. JDK 1.7 及以前的永久代(方法区)空间不足
   5. CMS GC处理浮动垃圾时，如果新生代空间不足，则采用空间分配担保机制，如果老年代空间不足，则触发Full GC

### 垃圾回收算法

1. 复制算法（Copying）

   将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。

   *注意：内存移动是必须实打实的移动（复制），不能使用指针玩。*

   专门研究表明，新生代中的对象98%是“朝生夕死”的，所以一般来说回收占据10%的空间够用了，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

   HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。

2. 标记-清除算法（Mark-Sweep）

   过程：

   1. 首先标记所有需要回收的对象
   2. 统一回收被标记的对象

   缺点：

   1. 效率问题，标记和清除效率都不高
   2. 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

3. 标记-整理算法（Mark-Compact）

   首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集

根据各个年代的特点选取不同的垃圾收集算法

新生代：使用复制算法

老年代：使用标记-整理或者标记-清除算法

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

### 垃圾回收器

老年代

- Serial Old：标记整理，单线程
- Parallel Old：标记整理，并行的多线程
- CMS：标记清除，并行与并发（与应用程序的多线程同时进行）
- G1：标记整理，并行与并发

新生代

- Serial：复制算法，单线程
- ParNew：复制算法，并行
- Parallel Scavenge：复制算法，并行
- G1   

#### GMS 垃圾回收过程

1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW -Stop the world）
2. 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。
3. 重新标记：l 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
4. 并发清除：不需要停顿。

优点：由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

缺点：

- CPU资源敏感：因为并发阶段多线程占据CPU资源，如果CPU资源不足，效率会明显降低。

- 浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。在1.6的版本中老年代空间使用率阈值(92%)

  如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

- 会产生空间碎片：标记 - 清除算法会导致产生不连续的空间碎片

#### G1 垃圾回收

`-XX:+UseG1GC`  使用G1垃圾回收器   

- 内部布局改变

  G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离

- 算法：

  1. 标记整理（humongous）
  2. 复制回收（survivor）

- GC模式

  1. Young GC

     选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。（复制回收算法）

  2. Mixed GC

     选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。

     Mixed GC不是full GC，它只能回收部分老年代的Region。如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。

- 全局并发标记（global concurrent marking）

  - 初始标记

    仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短

  - 并发标记

    从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行

  - 最终标记

    为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行

  - 筛选回收

    首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率

- 特点：

  1. 空间整理：不会产生内存碎片

  2. 算法：标记-整理（humongous），复制回收（survivor）

  3. 可预测的停顿：

     G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

     G1把内存“化整为零”

## JVM执行子系统

- 平台无关性
- 语言无关性

### Class 类文件（字节码）

Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

按顺序包括：

1. 魔数与class文件的版本

   每个Class文件的头4个字节称为魔数（Magic Number）,紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件

2. 常量池

3. 访问标志

4. 类索引，父类索引与接口索引集合

5. 字段表集合

6. 方法表集合

7. 属性表集合

8. 字节码指令

   1. 加载和存储指令
   2. 运算或算术指令
   3. 类型转换指令
   4. 创建类实例的指令
   5. 创建数组的指令
   6. 访问字段指令
   7. 数组存取相关指令
   8. 检查类实例类型的指令
   9. 操作数栈管理指令
   10. 控制转移指令
   11. 方法调用指令
   12. 方法返回指令
   13. 异常处理指令
   14. 同步指令

### 类加载机制

*编译器将代码编译成的字节码通过**<u>类加载</u>**后才能进行解释执行或JIT编译成机器码*

#### 类加载器

对于任意一个类来说，确定它的唯一性：类的全限定名 + 类加载器；

每个类加载器都拥有一个独立的类名称空间。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

- 用途：热加载、代码保护和加解密、类层次划分、OSGi等

- 自定义类加载对类进行加密和解密

- Bootstap ClassLoader 启动类加载器 jre/lib/*.jar

  这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader

  这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可

- Extension ClassLoader 扩展类加载器 jre/lib/ext/*.jar

  这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器

- Application ClassLoader 应用程序类加载器 CLASSPATH 程序jar

  这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

  我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

  双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。

- 自定义类加载器

  ClassLoader中的loadClass方法中的代码逻辑就是双亲委派模型：

  在自定义ClassLoader的子类时候，我们常见的会有两种做法，一种是重写**loadClass**方法，另一种是重写**findClass**方法。其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是从逻辑上讲我们最好不要直接修改loadClass的内部逻辑。我建议的做法是只在findClass里重写自定义类的加载方法。
   loadClass这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。

- Tomcat 类加载机制

  Tomcat本身也是一个java项目，因此其也需要被JDK的类加载机制加载，也就必然存在引导类加载器、扩展类加载器和应用(系统)类加载器。

  Common ClassLoader作为Catalina ClassLoader和Shared ClassLoader的parent，而Shared ClassLoader又可能存在多个children类加载器WebApp ClassLoader，一个WebApp ClassLoader实际上就对应一个Web应用，那Web应用就有可能存在Jsp页面，这些Jsp页面最终会转成class类被加载，因此也需要一个Jsp的类加载器。

  需要注意的是，在代码层面Catalina ClassLoader、Shared ClassLoader、Common ClassLoader对应的实体类实际上都是URLClassLoader或者SecureClassLoader，一般我们只是根据加载内容的不同和加载父子顺序的关系，在逻辑上划分为这三个类加载器；而WebApp ClassLoader和JasperLoader都是存在对应的类加载器类的。

  当tomcat启动时，会创建几种类加载器：

  **1 Bootstrap** **引导类加载器** 加载JVM启动所需的类，以及标准扩展类（位于jre/lib/ext下）

  **2 System** **系统类加载器** 加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。

  **3 Common** **通用类加载器** 加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME/lib下，比如servlet-api.jar

  **4 webapp** **应用类加载器**每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。

  

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

#### 双亲委派模型

1. 双亲委派过程：

   向上询问是否已加载，逐层向下询问是否已可加载

   某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载

2. 双亲委派好处

   Java类随着它的类加载器一起具备了带有优先级的层次关系，保证java程序稳定运行

##### 加载阶段

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构**
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

##### 验证

连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

##### 准备阶段

是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：

public static int value=123；

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。假设上面类变量value的定义变为：public static final int value=123；

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

##### 解析阶段

是虚拟机将常量池内的符号引用替换为直接引用的过程

##### 类初始化阶段

是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。

＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。

初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类
5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

特例

- 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化
- 数组形式的new(而不是构造方法)不会触发类初始化
- 直接打印类的常量会不会触发类的初始化：（坑：项目中有可能常量改了，关联使用的类不重新编译就会还是原来的值）
- 如果使用常量去引用另外一个常量，这个时候编译阶段无法进行优化，所以才会触发类的初始化

### JVM 性能优化

#### 内存溢出

内存溢出原因：程序在申请内存时，没有足够的内存空间

#### 栈溢出

方法死循环递归调用（StackOverflowError）、不断建立线程（OutOfMemoryError）

#### 堆溢出

不断创建对象，分配对象大于最大堆的大小（OutOfMemoryError/GC overhead limit exceeded）

#### 本地内存直接溢出 

（OutOfMemoryError: direct buffer memory）

分配的本地内存大小大于JVM的限制 (-XX:MaxDirectMemorySize=100m)

#### 方法区溢出

在经常动态生产大量Class的应用中，CGLIb字节码增强，动态语言，大量JSP(JSP第一次运行需要编译成Java类),基于OSGi的应用(同一个类，被不同的加载器加载也会设为不同的类)

#### 内存泄漏

程序在申请内存后，无法释放已申请的内存空间

#### 长生命周期的对象持有短生命周期对象的引用

例如将ArrayList设置为静态变量，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏

#### 连接未关闭

如数据库连接、网络连接和IO连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象

#### 变量作用域不合理

例如

1. 一个变量的定义的作用范围大于其使用范围
2. 如果没有及时地把对象设置为null

#### 内部类持有外部类

Java的非静态内部类的这种创建方式，会隐式地持有外部类的引用，而且默认情况下这个引用是强引用，因此，如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏

如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏（你认为垃圾回收器会回收掉外部类的实例，但由于内部类持有外部类的引用，导致垃圾回收器不能正常工作）

解决方法：你可以在内部类的内部显示持有一个外部类的软引用(或弱引用)，并通过构造方法的方式传递进来，在内部类的使用过程中，先判断一下外部类是否被回收；

#### Hash值改变

在集合中，如果修改了对象中的那些参与计算哈希值的字段，会导致无法从集合中单独删除当前对象，造成内存泄露

#### 内存泄漏和内存溢出辨析

*往往很多情况下，内存溢出往往是内存泄漏造成的。*

区别：

- 内存溢出：实实在在的内存空间不足导致
- 内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下

避免：

- 内存溢出：检查代码以及设置足够的空间
- 内存泄漏：一定是代码有问题

#### 了解MAT （[Eclipse Memory Analyzer](https://www.eclipse.org/mat/)）

`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$LOG_DIR/java.hprof"`

#### 深堆&浅堆

1. 浅堆：（Shallow Heap）是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。

2. 深堆：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被**直接**或**间接**访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。

   举例：对象A引用了C和D，对象B引用了E。那么对象A的浅堆大小只是A本身，而如果A被回收，那么C和D都会被回收(可达性分析算法)，所以A的深堆大小为A+C+D之和，同时由于对象E还可以通过对象B访问到，因此不在对象A的深堆范围内。

### JDK命令行工具

#### jps 虚拟机进程状况工具

列出当前机器上正在运行的虚拟机进程，JPS从操作系统的临时目录上去找。

-q :仅仅显示进程，

-m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数

-l: 输出应用程序主类完整package名称或jar完整名称.

-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数

#### jstat 虚拟机统计信息监视工具

是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。

假设需要每250毫秒查询一次进程13616垃圾收集状况，一共查询10次，那命令应当是：jstat-gc 13616  250 10

常用参数：

-class (类加载器) 

-compiler (JIT) 

-gc (GC堆状态) 

-gccapacity (各区大小) 

-gccause (最近一次GC统计和原因) 

-gcnew (新区统计)

-gcnewcapacity (新区大小)

-gcold (老区统计)

-gcoldcapacity (老区大小)

-gcpermcapacity (永久区大小)

-gcutil (GC统计汇总)

-printcompilation (HotSpot编译统计)

####  jinfo java配置信息工具

查看和修改虚拟机的参数

jinfo –sysprops 可以查看由System.getProperties()取得的参数

jinfo –flag 未被显式指定的参数的系统默认值

jinfo –flags（注意s）显示虚拟机的参数

jinfo –flag +[参数] 可以增加参数，但是仅限于由`java -XX:+PrintFlagsFinal –version查询出来且`

`为manageable`的参数

jinfo –flag -[参数] 可以去除参数

#### jmap java内存映射工具

用于生成堆转储快照（一般称为heapdump或dump文件）。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。

`jmap -dump:live,format=b,file=heap.bin <pid>`

Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。

#### jhat 虚拟机堆转存储快照分析工具

jhat dump文件名

后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以访问详情

使用jhat可以在服务器上生成堆转储文件分析（一般不推荐，毕竟占用服务器的资源，比如一个文件就有1个G）

#### jstack java堆栈跟踪工具

（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。

在代码中可以用java.lang.Thread类的getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。

### JDK 可视化工具

**管理远程进程需要在远程程序的启动参数中增加：**

-Djava.rmi.server.hostname=…..

-Dcom.sun.management.jmxremote

-Dcom.sun.management.jmxremote.port=8888

-Dcom.sun.management.jmxremote.authenticate=false

-Dcom.sun.management.jmxremote.ssl=false

#### jConsole java监视与管理控制台

#### VisualVM 多合一故障处理工具

### JVM调优和深入了解性能优化

JVM调优的本质：

并不是显著的提高系统性能，不是说你调了，性能就能提升几倍或者上十倍，JVM调优，主要调的是稳定。如果你的系统出现了频繁的垃圾回收，这个时候系统是不稳定的，所以需要我们来进行JVM调优，调整垃圾回收的频次。

#### GC调优原则

1. 大多数的java应用不需要GC调优
2. 大部分需要GC调优的的，不是参数问题，是代码问题
3. 在实际使用中，分析GC情况优化代码比优化GC参数要多得多
4. GC调优是最后的手段

#### GC调优目的

GC的时间够小

GC的次数够少

发生Full GC的周期足够的长，时间合理，最好是不发生。

注：如果满足下面的指标，则一般不需要进行GC：

  Minor GC执行时间不到50ms；

  Minor GC执行不频繁，约10秒一次；

  Full GC执行时间不到1s；

  Full GC执行频率不算频繁，不低于10分钟1次；

#### 调优步骤

##### 日志分析

1. 监控GC的状态

   使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；

2. 分析结果，判断是否需要优化

   如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；

3. 调整GC类型和内存分配

   如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；

4. 不断地分析和调整

   通过不断的试验和试错，分析并找到最合适的参数

5. 全面应用参数

   如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。

##### 阅读日志

主要关注MinorGC和FullGC 的回收效率（回收前大小和回收比较）、回收的时间

- ##### -XX:+UseSerialGC

  以参数-Xms5m -Xmx5m -XX:+PrintGCDetails -XX:+UseSerialGC为例：

  [DefNew: 1855K->1855K(1856K), 0.0000148 secs][Tenured: 2815K->4095K(4096K), 0.0134819 secs] 4671K

  DefNew指明了收集器类型，而且说明了收集发生在新生代。

  1855K->1855K(1856K)表示，回收前 新生代占用1855K，回收后占用1855K，新生代大小1856K。

  0.0000148 secs 表明新生代回收耗时。

  Tenured表明收集发生在老年代

  2815K->4095K(4096K), 0.0134819 secs：含义同新生代

  最后的4671K指明堆的大小。

- ##### -XX:+UseParNewGC

  收集器参数变为-XX:+UseParNewGC，日志变为：

  [ParNew: 1856K->1856K(1856K), 0.0000107 secs][Tenured: 2890K->4095K(4096K), 0.0121148 secs]

  收集器参数变为-XX:+ UseParallelGC或UseParallelOldGC，日志变为：

   [PSYoungGen: 1024K->1022K(1536K)] [ParOldGen: 3783K->3782K(4096K)] 4807K->4804K(5632K)

- ##### -XX:+UseConcMarkSweepGC

  CMS收集器和G1收集器会有明显的相关字样

- ##### -XX:+UseG1GC

### GC调优实战

- 项目启动GC优化

  开启日志分析，减小GC（FullGC，Minor gc）次数

- 项目运行GC优化

  使用工具 apache.jmeter压力测试

推荐策略

1. 新生代大小选择
   - 响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,新生代收集发生的频率也是最小的.同时,减少到达老年代的对象
   - 吞吐量有限的应用：尽可能地设置大，可能到达Gbit的程度，因为对响应时间没有要求，垃圾收集可以进行，一般适合8CPU以上的应用
   - 避免设置过小，当新生代设置过小时导致：1.MinorGC次数更加频繁 2.可能导致MinorGC对象直接进入老年代，如果老年代满了就会触发FullGC
2. 老年代大小选择
   - 响应时间优先的应用:老年代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎 片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:
      并发垃圾收集信息、持久代并发收集次数、传统GC信息、花在新生代和老年代回收上的时间比例。
   - 吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的新生代和一个较小的老年代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而老年代尽存放长期存活对象

#### 逃逸分析

对象在栈上分配，如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。

没有逃逸分析:对象都在堆上分配（触发频次GC，加重负担）

逃逸分析是JVM所做的最激进的优化，最好不要调整相关的参数。

牵涉到的JVM参数：

-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)

-XX:+EliminateAllocations：标量替换(默认打开) 

-XX:+UseTLAB 本地线程分配缓冲(默认打开) 

#### 常用的性能评价/测试指标

一个web应用不是一个孤立的个体，它是一个系统的部分，系统中的每一部分都会影响整个系统的性能

##### 响应时间

提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。

常用操作的响应时间列表：

| 操作                              | 响应时间 |
| --------------------------------- | -------- |
| 打开一个站点                      | 几秒     |
| 数据库查询一条记录（有索引）      | 十几毫秒 |
| 机械磁盘一次寻址定位              | 4毫秒    |
| 从机械磁盘顺序读取1M数据          | 2毫秒    |
| 从SSD磁盘顺序读取1M数据           | 0.3毫秒  |
| 从远程分布式换成Redis读取一个数据 | 0.5毫秒  |
| 从内存读取1M数据                  | 十几微妙 |
| Java程序本地方法调用              | 几微妙   |
| 网络传输2Kb数据                   | 1微妙    |

#####  并发数

同一时刻，对服务器有实际交互的请求数。

和网站在线用户数的关联：1000个同时在线用户数，可以估计并发数在5%到15%之间，也就是同时并发数在50~150之间。

##### 吞吐量

对单位时间内完成的工作量(请求)的量度

#### 常用的性能优化手段

避免过早优化

**不应该把大量的时间耗费在小的性能改进上，过早考虑优化是所有噩梦的根源。**

所以，我们应该编写清晰，直接，易读和易理解的代码，真正的优化应该留到以后，等到性能分析表明优化措施有巨大的收益时再进行。

但是过早优化，不表示我们就可以随便写代码，还是需要注重编写高效优雅的代码。

##### 进行系统性能测试

所有的性能调优，都有应该建立在性能测试的基础上，直觉很重要，但是要用数据说话，可以推测，但是要通过测试求证。

##### 寻找系统瓶颈，分而治之，逐步优化

性能测试后，对整个请求经历的各个环节进行分析，排查出现性能瓶颈的地方，定位问题，分析影响性能的的主要因素是什么？内存、磁盘IO、网络、CPU，还是代码问题？架构设计不足？或者确实是系统资源不足？

#### 前端优化常用手段

##### 浏览器/App

1. 减小请求数

   合并CSS，Js，图片，

   生产服务器提供的all的js文件

   http中的keep-alive(http1.1中默认开启)包括nginx

2. 使用客户端缓冲

   静态资源文件（css、图标等）缓存在浏览器中，有关的属性Cache-Control（相对时间）和Expires

   如果文件发生了变化，需要更新，则通过改变文件名来解决。

3. 启用压缩

   浏览器(zip),压缩率80%以上。

   减少网络传输量，但会给浏览器和服务器带来性能的压力，需要权衡使用

4. 资源文件加载顺序

   css放在页面最上面，js放在最下面。这样页面的体验才会比较好。

   浏览器会加载完CSS才会对页面进行渲染

   JS只要加载后就会立刻执行。（有些JS可能执行时间比较长）

5. 减少Cookie传输

   cookie包含在每次的请求和响应中，因此哪些数据写入cookie需要慎重考虑（静态资源不需要放入cookie）

6. 有好的提示

   有时候在前端给用户一个提示，就能收到良好的效果。毕竟用户需要的是不要不理他。

##### CDN加速

CDN，又称内容分发网络，本质是一个缓存，而且是将数据缓存在用户最近的地方。无法自行实现CDN的时候，可以根据经济实力考虑商用CDN服务。

##### 反向代理缓存

将静态资源文件缓存在反向代理服务器上，一般是Nginx。

##### WEB组件分离

将js，css和图片文件放在不同的域名下。可以提高浏览器在下载web组件的并发数。因为浏览器在下载同一个域名的的数据存在并发数限制。

#### 应用服务性能优化

##### 缓存

网站性能优化第一定律：优先考虑使用缓存优化性能

优先原则：缓存离用户越近越好

###### 缓存的基本原理和本质

缓存是将数据存在访问速度较高的介质中。可以减少数据访问的时间，同时避免重复计算。

###### 合理使用缓存的准则

频繁修改的数据，尽量不要缓存，读写比2:1以上才有缓存的价值。

缓存一定是热点数据。

应用需要容忍一定时间的数据不一致。

缓存可用性问题，一般通过热备或者集群来解决

##### 分布式缓存与一致性哈希

以集群的方式提供缓存服务，有两种实现:

1. 需要更新同步的分布式缓存，所有的服务器保存相同的缓存数据，带来的问题就是，缓存的数据量受限制，其次，数据要在所有的机器上同步，代价很大。

2. 每台机器只缓存一部分数据，然后通过一定的算法选择缓存服务器。常见的余数hash算法存在当有服务器上下线的时候，大量缓存数据重建的问题。所以提出了一致性哈希算法。

 一致性哈希：

1.  首先求出服务器（节点）的哈希值，并将其配置到0～2的32次方的圆（continuum）上
2. 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上
3. 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上

   ***一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性***

 **数据倾斜：**

一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布 。

##### 集群

可以很好的将用户的请求分配到多个机器处理，对总体性能有很大的提升

##### 异步

同步和异步关注的是结果消息的通信机制

同步:同步的意思就是调用方需要主动等待结果的返回

异步:异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。

阻塞和非阻塞主要关注的是等待结果返回调用方的状态

阻塞:是指结果返回之前，当前线程被挂起，不做任何事

非阻塞:是指结果在返回之前，线程可以做一些其他事，不会被挂起。

1. 同步阻塞:同步阻塞基本也是编程中最常见的模型，打个比方你去商店买衣服，你去了之后发现衣服卖完了，那你就在店里面一直等，期间不做任何事(包括看手机)，等着商家进货，直到有货为止，这个效率很低。jdk里的BIO就属于 同步阻塞
2. 同步非阻塞:同步非阻塞在编程中可以抽象为一个轮询模式，你去了商店之后，发现衣服卖完了，这个时候不需要傻傻的等着，你可以去其他地方比如奶茶店，买杯水，但是你还是需要时不时的去商店问老板新衣服到了吗。jdk里的NIO就属于 同步非阻塞
3. 异步阻塞:异步阻塞这个编程里面用的较少，有点类似你写了个线程池,submit然后马上future.get()，这样线程其实还是挂起的。有点像你去商店买衣服，这个时候发现衣服没有了，这个时候你就给老板留给电话，说衣服到了就给我打电话，然后你就守着这个电话，一直等着他响什么事也不做。这样感觉的确有点傻，所以这个模式用得比较少
4. 异步非阻塞:好比你去商店买衣服，衣服没了，你只需要给老板说这是我的电话，衣服到了就打。然后你就随心所欲的去玩，也不用操心衣服什么时候到，衣服一到，电话一响就可以去买衣服了。jdk里的AIO就属于异步

常见的异步手段：

- Servlet异步

  servlet3中才有，支持的web容器在tomcat7和jetty8以后。


